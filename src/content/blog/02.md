---
title: Deploying applications on a nixos VPS
description: A guide to deploy a backend server to a digitalocean droplet running nixos.
author: quantinium
date: '2025-07-21'
categories:
  - deployment
  - nixos
  - backend
published: true
cover_image: 
---

NOTE: IN DRAFT

This is in continuation of the blog i wrote earlier on [installing nixos on vps](https://quantinium.dev/blog/01). In this post we are gonna package the rust program and deploy it on the vps and configure nginx so that its accessible anywhere.

# Part 1 - Building And Deploying

For demonstration purposes, i have created a simple backend which just reqwests [yerkee.com](http://yerkee.com/api/fortune) and sends fortune as json response.

```rust
// main.rs
use axum::{Router, response::Json, routing::get};
use reqwest::StatusCode;
use serde::{Deserialize, Serialize};

#[derive(Serialize)]
struct Message {
    message: String,
}

#[derive(Deserialize)]
struct Fortune {
    fortune: String,
}

#[tokio::main]
async fn main() {
    let app = Router::new().route("/", get(get_fortune));

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    println!("Server running at: http://localhost:3000");
    axum::serve(listener, app).await.unwrap();
}

async fn get_fortune() -> Result<Json<Message>, StatusCode> {
    let body = reqwest::get("http://yerkee.com/api/fortune")
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .json::<Fortune>()
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(Message {
        message: body.fortune,
    }))
}
```

Now if you try <u>cargo build</u> it would give a build error due to openssl. During development these are fixed by creating dev environments and just exporting the needed the libraries. Similarly while building it we just export the needed libraries too. 

Push all the code to github and run this to get the commit hash of your repository as we are gonna build it from there.
```shell
$ nix-prefetch-git https://github.com/quantinium3/fortune-cookie.git --branch-name main
{
  "url": "https://github.com/quantinium3/fortune-cookie.git",
  "rev": "1518c312a13dc6593666b2d38c01f24e8719b2e6",
  #...
  "hash": "sha256-ehkM8XvKHysYVaH5xdleVsatCtSfUrWxOC/9ADakGbg=",
  #...
}
```

Create a <u>flake.nix</u> at the root of your repo
```nix
# flake.nix
{
  description = "Fortune cookie backend";

  inputs = {
    flake-utils.url = "github:numtide/flake-utils";
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-25.05";
  };

  outputs = { nixpkgs, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = import nixpkgs {
          inherit system;
        };
      in
      {
        packages.default = pkgs.rustPlatform.buildRustPackage rec {
          pname = "fortune-cookie-${version}";
          version = "0.1.0";
          src = pkgs.fetchFromGitHub {
            owner = "quantinium3";
            repo = "fortune-cookie";
            rev = "1518c312a13dc6593666b2d38c01f24e8719b2e6"; # replace with the rev we got earlier
            sha256 = "sha256-ehkM8XvKHysYVaH5xdleVsatCtSfUrWxOC/9ADakGbg="; # replace with the hash we got earlier
          };
          cargoLock = { lockFile = ./Cargo.lock; };
          buildInputs = with pkgs; [ openssl ];

          OPENSSL_DIR = "${pkgs.openssl.dev}";
          OPENSSL_LIB_DIR = "${pkgs.openssl.out}/lib";
        };
      });
}
```

In it we have two inputs `nixpkgs` and `flake-utils` to simplify creating flake output for various systems. Nix provides a builtin module to simplify creating rust packages using `buildRustPackage`. In it we have the following input
- pname - name of the package
- version - version of the current package
- src - we are gonna fetch the source code from github with the specific commit hash.
- cargoLock - lockfile generated by cargo 
- buildInputs - packages needed while building the package
- enviroment variables - we are specifying openssl path's during build time so ensure linking against openssl.

That's it. run `nix build` and it should output a symlink `result` and we can run the server using `./result/bin/fortune-cookie`.

Just commit and push stuff to whatever platform you store code on. For convenience I'll just go with github. For testing that we can use it as a flake run 

```shell
$ nix build github:quantinium3/fortune-cookie && ./result/bin/fortune-cookie
Server running at: http://localhost:3000
```

We can use this package inside of our `flake.nix` but putting the input url as our github repo. 
```nix
# flake.nix
inputs.fortune-cookie.url =  "github:quantinium3/fortune-cookie";
```

In our configuration we can add this to install the server.
```nix
environment.systemPackages = [ inputs.fortune-cookie.packages.${pkgs.system}.default ];
```

If we wanna run it automatically, we can setup a systemd process that can run and manage this binary
```nix
  systemd.services.fortune-cookie {
    description = "Fortune Cookie Backend";
    after = [ "network.target" ];
    wantedBy = [ "multi-user.target" ];
    serviceConfig = {
      ExecStart = "${inputs.fortune-cookie.packages.${pkgs.system}.default}/bin/fortune-cookie";
      Restart = "always";
      StandardOutput = "journal";
      StandardError = "journal";
    };
  };
```

After deploying, we can check the service status and also check if the service is running by doing a get request
```
$ deploy
$ ssh nixie curl http://localhost:3000 | jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    61  100    61    0     0    117      0 --:--:-- --:--:-- --:--:--   117
{
  "message": "COBOL:\n\tAn exercise in Artificial Inelegance."
}
```

Now to point this to a domain we can use nginx as a reverse proxy to redirect the requests from the domain to our server running on localhost. Configure your dns provider, nginx and lets encrypt and now we can access this no a [domain](https://fortune.quantinium.dev)


```nix
  services.nginx = {
    enable = true;

    #... general nginx configuration 
    virtualHosts = {
      "fortune.quantinium.dev" = {
        enableACME = true;
        locations = {
          "/" = {
            proxyPass = "http://127.0.0.1:3000";
          };
        };
      };
    };
  };
```

We have deployed our rust server on our nixos vps successfully.

# Part - 3 Cachix
Cachix is a service for hosting and sharing nix binaries. Instead of rebuilding the packages on every deployment or across multiple machines, we can push pre-built binaries to cachix cache and our systems can then download these binaries instead of rebuilding them.

Normally when you rebuild your system, nix checks if there is any change in the input's source code or dependencies and rebuild the package if there is a change but if no change happens it'll just reuse the package stored at `/nix/store` and not rebuild it again. For most part its fine as our system maybe is not that much changing but i wanted to include cachix here cause it's cool.

Since we have a github repo with the code and `flake.nix`, We can setup a github action that build the package whenever we change the flake.nix or flake.lock. Why not build on push to main? well in our `flake.nix` we have pinned the commit hash so in order to have a new binary we have change the commit hash and building everytime when main updates is just redundant.

```yaml
name: build and cache fortune
on:
  push:
    branches:
      - main
    paths:
      - 'flake.nix'
      - 'flake.lock'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: checkout repo
        uses: actions/checkout@v4

      - name: install nix action
        uses: cachix/install-nix-action@v31

      - name: install cachix action
        uses: cachix/cachix-action@v15
        with:
          name: quantinium3
          authToken: "${{ secrets.CACHIX_AUTH_TOKEN }}"

      - name: build package
        run: nix build .#default

      - name: push to cachix
        run: cachix push quantinium3 ./result

      - name: trigger nixos deployment
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.REPO_DISPATCH_TOKEN }}
          repository: quantinium3/nixie
          event-type: fortune_cookie_updated
```

In the workflow we are basically installing nix and cachix action to build the package and push package(binary and its related dependencies) to cachix. We can also add a repository dispatch action that can run another workflow in our server configuration to update flake.lock to the newest commit and deploy it to the vps.

an example of updating the server config automatically can be like
```yaml
name: update flake lock
on:
  repository_dispatch:
    types: [ fortune_cookie_updated ]

concurrency:
  group: update-flake
  cancel-in-progress: true

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: checkout repo
        uses: actions/checkout@v4
        with:
          ref: master

      - name: install nix
        uses: cachix/install-nix-action@v31

      - name: update flake.lock
        run: nix flake lock --update-input fortune-cookie

      - name: verify update
        run: git diff --exit-code flake.lock || echo "flake.lock updated"

      - name: commit changes
        uses: stefanzweifel/git-auto-commit-action@v6
        with:
          commit_message: "chore: update fortune-cookie input in flake.lock"
```

Now if the upstream package (our backend) changes it'll trigger update of `flake.lock` in our server configuration. We can also make a second workflow such that if flake.lock changes it'll automatically trigger deploy of our configuration.

```yaml
name: deploy nixos configuration
on:
  push:
    branches:
      - master

concurrency:
  group: deploy-vps
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: checkout repo
        uses: actions/checkout@v4
        with:
          ref: master

      - name: install nix
        uses: cachix/install-nix-action@v31

      - name: setup cachix
        uses: cachix/cachix-action@v15
        with:
          name: quantinium3
          authToken: ${{ secrets.CACHIX_AUTH_TOKEN }}

      - name: setup ssh
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/nixie
          chmod 600 ~/.ssh/nixie
          echo "${{ secrets.SSH_CONFIG }}" > ~/.ssh/config
          chmod 644 ~/.ssh/config
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts

      - name: deploy to vps
        run: |
          nix run github:serokell/deploy-rs -- .#vps

      - name: Deploy to VPS
        run: nix run github:serokell/deploy-rs
```

This workflow installs nix and cachix on our runner, setups ssh config to push our config to run `deploy-rs`.

note to self :- 
- write a module that abstract the systemd service to smth like `fortune-cookie.enable = true;`
- add references

I think this does it. Writing these blogs have made me realize how cool nix/nixos ecosystem is and how everything is managed and packaged.

> Note: if you are trying to officially package stuff for nixpkgs kindly refer to [nur-packages-template](https://github.com/nix-community/nur-packages-template) for a providing a better structure and contributing to nixpkgs.

Well if you have read this far. First of all thank you. If you have any queries, requests, changes or anything feel free to dm me on any of my socials. 

